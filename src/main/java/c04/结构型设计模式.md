结构型设计模式总结了一些类或对象组合在一起的经典结构,这些经典的结构可以解决特定的应用场景的问题.

## 代理模式
在不改变原始类代码的情况下, 通过引入代理类来给原始类附加功能.

### 0. 不采用代理模式的代码
[Demo](proxy/UserController.java)

很明显,Demo的写法有两个问题,

① 性能计数器代码侵入到业务中,跟业务代码高度耦合,框架替换的话成本比较大

② 违背了单一职责原则,把接口计数器跟用户业务放到一个类里. 

### 1. 基于接口实现代理模式
[Demo](proxy/m1impl/UserProxy.java)

上述代码就是用UserProxy作为UserController的扩展实现了请求计数.
这个实现有一个问题就是,如果原始类UserController并不是我们开发维护的(比如来自一个第三方的包),
修改UserController实现接口就无法实现了.

### 2. 通过继承实现
[Demo](proxy/m2extends/UserControllerProxy.java)

通过继承的代码还是有点问题,

一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。

另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类

### 3. 动态代理实现

[Demo](proxy/m3dynamic/MetricsProxy.java)
实际上，Spring AOP 底层的实现原理就是基于动态代理。
用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。
Spring为这些类创建动态代理对象，并在 JVM 中替代原始类对象。
原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。